import fs from "node:fs/promises";
import path from "node:path";
import { isNil, mustExist } from "@oliversalzburg/js-utils/data/nil.js";
import { InvalidOperationError } from "@oliversalzburg/js-utils/errors/InvalidOperationError.js";

export const SCRIPTS_METADATA_DEFAULT_FILENAME = "package.json-scripts.json";

/**
 * A single entry in the script store.
 */
export class ScriptStoreEntry {
  /**
   * The path where the manifest is located.
   */
  manifestPath: string;

  /**
   * The name of the project this script exists in.
   */
  projectName: string;

  /**
   * The name of the script itself.
   */
  scriptName: string;

  /**
   * The code of the script.
   */
  scriptCode: string;

  /**
   * Is this a global script?
   * Scripts are usually global when their name includes a colon.
   */
  isGlobal: boolean;

  /**
   * Is this a script from the root manifest of the monorepo?
   */
  isRootManifest: boolean;

  /**
   * The user-authored description of the script.
   */
  description?: string | undefined;

  /**
   * Constructs a new script store entry.
   * @param manifestPath - The path where the manifest is located.
   * @param projectName - The name of the project this script exists in.
   * @param scriptName - The name of the script itself.
   * @param scriptCode - The code of the script.
   * @param isGlobal - Is this a global script?
   * @param isRootManifest - Is this a script from the root manifest of the monorepo?
   */
  constructor(
    manifestPath: string,
    projectName: string,
    scriptName: string,
    scriptCode: string,
    isGlobal: boolean,
    isRootManifest = false,
  ) {
    this.manifestPath = manifestPath;
    this.projectName = projectName;
    this.scriptName = scriptName;
    this.scriptCode = scriptCode;
    this.isGlobal = isGlobal;
    this.isRootManifest = isRootManifest;
  }
}

/**
 * The script store.
 */
export class ScriptStore {
  /**
   * Our default comment.
   */
  readonly comment = "This file is generated by node-scripts-docs.";

  /**
   * The actual scripts in the store.
   */
  scripts = new Array<ScriptStoreEntry>();

  /**
   * The current schema version of the script store.
   */
  readonly version: number = 1;

  #filename: string;
  #rootDirectory: string;

  /**
   * Retrieve all scripts that are global.
   * @returns All scripts that are global.
   */
  get globalScripts() {
    return this.scripts.filter(scriptMeta => scriptMeta.isGlobal);
  }

  /**
   * Constructs a new script store.
   * @param rootDirectory - The root directory of the project.
   * @param filename - The name of the file where we persist script metadata.
   */
  constructor(rootDirectory: string, filename = SCRIPTS_METADATA_DEFAULT_FILENAME) {
    this.#rootDirectory = rootDirectory;
    this.#filename = filename;
  }

  /**
   * Add a new script to the store.
   * @param manifestPath - The path where the manifest is located.
   * @param projectName - The name of the project this script exists in.
   * @param scriptName - The name of the script itself.
   * @param scriptCode - The code of the script.
   * @param isGlobal - Is this a global script?
   * @param isRootManifest - Is this a script from the root manifest of the monorepo?
   */
  add(
    manifestPath: string,
    projectName: string,
    scriptName: string,
    scriptCode: string,
    isGlobal: boolean,
    isRootManifest = false,
  ) {
    this.scripts.push(
      new ScriptStoreEntry(
        manifestPath,
        projectName,
        scriptName,
        scriptCode,
        isGlobal,
        isRootManifest,
      ),
    );

    // Assume consistent order is best preserved on insert.
    this.scripts.sort(
      (a, b) =>
        a.scriptName.localeCompare(b.scriptName) || a.projectName.localeCompare(b.projectName),
    );
  }

  /**
   * Save the store metadata to disc.
   * @param filename - The file to save the metadata to.
   * @returns A promise that is fulfilled once the metadata has been written to disc.
   */
  save(filename?: string): Promise<void> {
    return fs.writeFile(
      path.resolve(this.#rootDirectory, filename ?? this.#filename),
      JSON.stringify(this, undefined, 2),
    );
  }

  /**
   * Load script metadata from the given file.
   * @param filename - The file to load the metadata from.
   */
  async load(filename?: string) {
    const storeContent = await fs.readFile(
      path.resolve(this.#rootDirectory, filename ?? this.#filename),
      "utf-8",
    );
    const store = JSON.parse(storeContent) as ScriptStore;
    if (store.version !== this.version) {
      throw new Error("Unexpected version mismatch!");
    }
    this.scripts = mustExist(store.scripts);
  }

  /**
   * Generates a locator name for a script.
   * @param projectName - The name if the project.
   * @param scriptName - The name of the script.
   * @returns A locator name.
   */
  static makeScriptLocator(projectName: string, scriptName: string) {
    return `${scriptName}→${projectName}`;
  }

  /**
   * Parse a script locator into the project and script name parts.
   * @param locator - The script locator.
   * @returns The project and script name the locator refers to.
   */
  static parseScriptLocator(locator: string) {
    const parts = /([^→]+)→(.+)/.exec(locator);
    if (isNil(parts)) {
      throw new InvalidOperationError(`The locator '${locator}' is invalid.`);
    }

    return {
      projectName: parts[2],
      scriptName: parts[1],
    };
  }

  /**
   * Check if a store exists at the given location.
   * @param storePath - A path where a store might exist.
   * @returns `true` if the store exists; `false` otherwise.
   */
  static async exists(storePath: string) {
    try {
      await fs.stat(storePath);
    } catch {
      return false;
    }

    return true;
  }
}
